import os
import json
import shutil
import subprocess
import signal
from typing import Optional
from sqlalchemy.orm import Session

from app.config import settings
from app.models.project import Project, ProjectStatus
from app.models.scene import Scene

# Track running studio processes: project_id -> subprocess.Popen
_studio_processes: dict[int, subprocess.Popen] = {}


def write_remotion_data(project: Project, scenes: list[Scene], db: Session) -> str:
    """
    Write scene data and assets to the Remotion project's public folder
    so the video components can load them at runtime.

    Returns:
        str: Path to the generated data.json file
    """
    remotion_dir = settings.REMOTION_PROJECT_PATH
    public_dir = os.path.join(remotion_dir, "public")
    os.makedirs(public_dir, exist_ok=True)

    # Build scene data
    scene_data = []
    for scene in scenes:
        # Copy voiceover files to remotion public
        voiceover_filename = None
        if scene.voiceover_path and os.path.exists(scene.voiceover_path):
            voiceover_filename = f"audio_scene_{scene.order}.mp3"
            dest = os.path.join(public_dir, voiceover_filename)
            _copy_file(scene.voiceover_path, dest)

        # Copy images referenced by the scene to remotion public
        image_files = []
        for asset in project.assets:
            if asset.asset_type.value == "image" and os.path.exists(asset.local_path):
                dest = os.path.join(public_dir, asset.filename)
                _copy_file(asset.local_path, dest)
                image_files.append(asset.filename)

        scene_data.append({
            "id": scene.id,
            "order": scene.order,
            "title": scene.title,
            "narration": scene.narration_text,
            "visualDescription": scene.visual_description,
            "durationSeconds": scene.duration_seconds,
            "voiceoverFile": voiceover_filename,
            "images": image_files,
        })

    # Write data.json
    data = {
        "projectName": project.name,
        "scenes": scene_data,
    }
    data_path = os.path.join(public_dir, "data.json")
    with open(data_path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2)

    return data_path


def write_scene_components(scenes: list[Scene]) -> None:
    """
    Write individual Remotion scene component files generated by DSPy.
    Falls back to a default template if no code was generated.
    """
    components_dir = os.path.join(
        settings.REMOTION_PROJECT_PATH, "src", "components", "generated"
    )
    os.makedirs(components_dir, exist_ok=True)

    for scene in scenes:
        filename = f"Scene{scene.order}.tsx"
        filepath = os.path.join(components_dir, filename)

        if scene.remotion_code:
            code = scene.remotion_code
        else:
            code = _default_scene_component(scene)

        with open(filepath, "w", encoding="utf-8") as f:
            f.write(code)

    # Write an index file that exports all scenes
    index_path = os.path.join(components_dir, "index.ts")
    exports = []
    for scene in scenes:
        exports.append(
            f'export {{ default as Scene{scene.order} }} from "./Scene{scene.order}";'
        )
    with open(index_path, "w", encoding="utf-8") as f:
        f.write("\n".join(exports) + "\n")


def launch_studio(project: Project, db: Session) -> int:
    """
    Launch Remotion Studio as a subprocess.

    Returns:
        int: The port number the studio is running on
    """
    # Kill existing studio for this project
    stop_studio(project.id)

    remotion_dir = settings.REMOTION_PROJECT_PATH

    # Find an available port (start from 3100 to avoid conflicts)
    port = 3100 + (project.id % 100)

    # On Windows, npx must be called as npx.cmd or via shell
    npx = shutil.which("npx") or "npx"
    cmd = [
        npx, "remotion", "studio",
        "--port", str(port),
        "--no-open",
    ]

    process = subprocess.Popen(
        cmd,
        cwd=remotion_dir,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        shell=(os.name == "nt"),
        creationflags=subprocess.CREATE_NEW_PROCESS_GROUP if os.name == "nt" else 0,
    )

    _studio_processes[project.id] = process

    # Update project with studio port
    project.studio_port = port
    db.commit()

    return port


def stop_studio(project_id: int) -> None:
    """Stop a running Remotion Studio subprocess."""
    process = _studio_processes.pop(project_id, None)
    if process and process.poll() is None:
        try:
            if os.name == "nt":
                process.terminate()
            else:
                os.killpg(os.getpgid(process.pid), signal.SIGTERM)
        except (ProcessLookupError, OSError):
            pass


def render_video(project: Project) -> str:
    """
    Render the video using Remotion CLI.

    Returns:
        str: Path to the output video file
    """
    remotion_dir = settings.REMOTION_PROJECT_PATH
    output_dir = os.path.join(settings.MEDIA_DIR, f"projects/{project.id}/output")
    os.makedirs(output_dir, exist_ok=True)

    output_path = os.path.join(output_dir, "video.mp4")

    npx = shutil.which("npx") or "npx"
    cmd = [
        npx, "remotion", "render",
        "ExplainerVideo",
        output_path,
    ]

    result = subprocess.run(
        cmd,
        cwd=remotion_dir,
        shell=(os.name == "nt"),
        capture_output=True,
        text=True,
        timeout=600,  # 10 minute timeout
    )

    if result.returncode != 0:
        raise RuntimeError(f"Remotion render failed: {result.stderr}")

    return output_path


def _copy_file(src: str, dest: str) -> None:
    """Copy a file from src to dest."""
    import shutil
    if os.path.abspath(src) != os.path.abspath(dest):
        shutil.copy2(src, dest)


def _default_scene_component(scene: Scene) -> str:
    """Generate a default Remotion scene component."""
    return f'''import {{ AbsoluteFill, interpolate, useCurrentFrame, useVideoConfig }} from "remotion";

const Scene{scene.order}: React.FC<{{
  title: string;
  narration: string;
  imageUrl?: string;
}}> = ({{ title, narration, imageUrl }}) => {{
  const frame = useCurrentFrame();
  const {{ fps }} = useVideoConfig();

  const titleOpacity = interpolate(frame, [0, 30], [0, 1], {{
    extrapolateRight: "clamp",
  }});
  const textY = interpolate(frame, [10, 40], [30, 0], {{
    extrapolateRight: "clamp",
  }});
  const textOpacity = interpolate(frame, [10, 40], [0, 1], {{
    extrapolateRight: "clamp",
  }});

  return (
    <AbsoluteFill
      style={{{{
        backgroundColor: "#0f172a",
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        padding: 80,
      }}}}
    >
      <h1
        style={{{{
          color: "#f1f5f9",
          fontSize: 56,
          fontWeight: 700,
          opacity: titleOpacity,
          marginBottom: 24,
        }}}}
      >
        {{title}}
      </h1>
      <p
        style={{{{
          color: "#cbd5e1",
          fontSize: 28,
          lineHeight: 1.6,
          opacity: textOpacity,
          transform: `translateY(${{textY}}px)`,
          maxWidth: 900,
        }}}}
      >
        {{narration}}
      </p>
    </AbsoluteFill>
  );
}};

export default Scene{scene.order};
'''
